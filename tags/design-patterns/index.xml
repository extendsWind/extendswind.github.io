<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design patterns on extendswind</title>
    <link>http://extendswind.github.io/tags/design-patterns/</link>
    <description>Recent content in Design patterns on extendswind</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 02 Jul 2018 11:25:25 +0800</lastBuildDate>
    
	<atom:link href="http://extendswind.github.io/tags/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式 之 单例模式</title>
      <link>http://extendswind.github.io/posts/technical/design_patterns_singleton/</link>
      <pubDate>Mon, 02 Jul 2018 11:25:25 +0800</pubDate>
      
      <guid>http://extendswind.github.io/posts/technical/design_patterns_singleton/</guid>
      <description>singleton pattern
主要目标：得到一个对象，对象只创建一次，并保证每次得到相同的对象。
实现思想：使用静态方法getInstance得到对象，为了保证对象只能通过getInstance创建，使构造函数私有。
主要麻烦在于：
 多线程环境下getInstance方法的调用可能产生多个对象 使用synchronized关键字可能降低高并发效率  单例模式有很多种，大多用于解决多线程环境下的效率问题，高并发场景可以具体搜索相关方案，一般情况下思想比较简单感觉不必深究。
（后面懒得用实际例子命名了，Log4j中获取的logger对象就使用了单例模式）
/** * 简单实现 * * 存在的问题： * * 当创建过程需要时间时，连续调用getInstance方法会导致创建多个对象，特别是涉及多线程时容易出问题。 */ class Singleton_problem { private static Singleton_problem m_singletonProblem = null; private Singleton_problem(){ // ...  } public static Singleton_problem getInstance(){ if (m_singletonProblem == null) m_singletonProblem = new Singleton_problem(); return m_singletonProblem; } } /** * 解决方案一： eager initialization * * 缺点在于没有lazy loading机制 */ class Singleton_eager{ private static final Singleton_eager m_singleton = new Singleton_eager(); private Singleton_eager(){ // .</description>
    </item>
    
    <item>
      <title>设计模式 之 静态代理模式和装饰者模式</title>
      <link>http://extendswind.github.io/posts/technical/design_patterns_static_proxy_and_decoration/</link>
      <pubDate>Wed, 20 Jun 2018 17:25:25 +0800</pubDate>
      
      <guid>http://extendswind.github.io/posts/technical/design_patterns_static_proxy_and_decoration/</guid>
      <description>这两种模式的相似度极高，作用也类似，都是对已有的类进行包装，以添加新的控制（代理模式）和功能（装饰者模式），其实这两点也没有严格区分。
两种设计模式的重点在于，已有的类（被代理、被装饰）与新类（代理类、装饰类）都实现同一接口，通过接口调用新类会和调用已有的类相同。
设计模式中常说使用“组合”优先于“继承”。对于想要改变一个写好的类中的某些功能，一般情况下使用继承的灵活性不如组合。继承的某些缺点：单继承（多继承也面临一些问题）、破坏封装（子类可能改变某些细节），父类的改变对子类可能有影响。“组合”的方式将需要被修改或加强的类作为新类的类成员，可以通过添加多个类成员以得到组合多种功能的效果。
静态代理模式 （static proxy） 静态代理的思想：将被代理类作为代理类的成员，通过代理类调用被代理类的函数，并添加新的控制。包装类与被包装类实现同一接口，使得使用时的代码一致。
应用：已经有一个日志记录器LoggerSubject，需要对writeLog()函数的前后进行某些操作（如初始化、异常处理等），使用Proxy类间接调用LoggerSubject.writeLog()实现新控制操作的添加。
实现如下
interface Logger { void writeLog(); } // 被代理类 class LoggerSubject implements Logger{ @Override public void writeLog(){ System.out.println(&amp;#34;writeLog by LoggerSubject&amp;#34;); } } // 代理类 class Proxy implements Logger{ Logger logger; // 与装饰者模式的主要区别位置  // 代理模式一般要求和原来的类行为一致，因此构造函数不传入对象  Proxy(){ this.logger = new LoggerSubject(); } @Override public void writeLog(){ System.out.println(&amp;#34;logger write before&amp;#34;); logger.writeLog(); System.out.println(&amp;#34;logger write after&amp;#34;); } } public class StaticProxy { private static void write(Logger logger){ logger.</description>
    </item>
    
    <item>
      <title>设计模式 之 工厂模式</title>
      <link>http://extendswind.github.io/posts/technical/design_patterns_factory/</link>
      <pubDate>Fri, 15 Jun 2018 17:25:25 +0800</pubDate>
      
      <guid>http://extendswind.github.io/posts/technical/design_patterns_factory/</guid>
      <description>几种工厂模式(Factory Pattern)简介 工厂模式主要分为：
 简单工厂模式（Simple Factory Pattern） 工厂方法模式（Factory Method Pattern 经常简称为工厂模式） 抽象工厂模式（Abstract Factory Pattern）  主要思想：将类的初始化过程转移到工厂类中，使用类的位置通过工厂类直接得到产品类，使产品类的初始化逻辑清晰，并容易添加新的产品。
需求示例 简单工厂模式 和 工厂方法模式  实现多个日志记录器logger(文件logger，数据库logger等) 通过配置文件确定使用的具体logger类 添加新的logger类不修改源码（添加新的java包并修改配置文件）  抽象工厂模式 抽象工厂模式应用场景略有不同。
存在多种不同的主题，每个主题都有不同的Button和Text的实现逻辑，因此每个主题都有Button和Text控件的派生类，导致类的初始化较多。
容易添加新的主题
不应用工厂模式的一般实现 （FactoryProblem.java）  logger 基类实现通用的日志记录功能，子类实现各自的特有功能 使用时根据配置文件中的类型，new相应的子类  类的实现：
abstract class Logger { public void writeLog(){ System.out.println(&amp;#34;writeLog by Logger&amp;#34;); } // 可添加公共实现 } class FileLogger extends Logger { @Override public void writeLog(){ System.out.println(&amp;#34;writeLog by the FileLogger&amp;#34;); } } class DataBaseLogger extends Logger { @Override public void writeLog(){ System.</description>
    </item>
    
  </channel>
</rss>