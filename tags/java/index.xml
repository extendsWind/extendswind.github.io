<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on A Notebook of Extendswind</title>
    <link>https://extendswind.top/tags/java/</link>
    <description>Recent content in java on A Notebook of Extendswind</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 19 May 2020 11:30:00 +0800</lastBuildDate>
    
	<atom:link href="https://extendswind.top/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java从toArray返回Object[]到泛型的类型擦除</title>
      <link>https://extendswind.top/posts/technical/java_toarray_return_and_generic_type_erase/</link>
      <pubDate>Tue, 19 May 2020 11:30:00 +0800</pubDate>
      
      <guid>https://extendswind.top/posts/technical/java_toarray_return_and_generic_type_erase/</guid>
      <description>在将ArrayList等Collection转为数组时，函数的返回值并不是泛型类型的数组，而是Object[]。刚好最近翻了一遍《java核心技术》，以及参考《Think in Java》，写写为什么没有直接返回对应类型的数组，以及Java泛型中类型擦除的处理方式。
主要涉及：
 ArrayList的toArray函数使用 为什么不直接定义函数 T[] toArray() 泛型数组的创建的两种常用方法 在泛型中创建具体的类实例  (部分代码没有运行过）
ArrayList的toArray函数使用 将ArrayList转为数组，提供了两个函数
Object[] toArray(); &amp;lt;T&amp;gt; T[] toArray(T[] a); // 后面考虑一个Integer类型的ArrayList ArrayList&amp;lt;Integer&amp;gt; aa = new ArrayList&amp;lt;&amp;gt;(); aa.add(1); aa.add(3); Object[] toArray(); 第一个函数是直接将ArrayList转换成Object的数组，可以用Object[] bb = aa.toArray()，在具体使用时对每个对象进行强制类型转换，如System.out.println((Integer)bb[1])。（java不支持数组之间的强制类型转换）
T[] toArray(T[] a); 第二个函数能够直接得到T类型的数组，当传入的T[] a能放下ArrayList时，会将ArrayList中的内容复制到a中（a的size较大时会a[size]=null）。否则，将构建一个新的数组并返回。具体实现如下:
public &amp;lt;T&amp;gt; T[] toArray(T[] a) { if (a.length &amp;lt; size) // Make a new array of a&amp;#39;s runtime type, but my contents:  return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.</description>
    </item>
    
    <item>
      <title>log4j 1.2 配置和使用简述</title>
      <link>https://extendswind.top/posts/technical/log4j_properties_simple_introduction/</link>
      <pubDate>Wed, 29 May 2019 20:30:00 +0800</pubDate>
      
      <guid>https://extendswind.top/posts/technical/log4j_properties_simple_introduction/</guid>
      <description>简述 使用log4j可以根据配置文件控制输出日志的级别，记录到文件、命令行等的位置，不需要代码上的更改。
日志在一定程度上会影响性能，特别是高并发环境。一般更建议使用log4j 2.x，在性能上有较大的提高，由于hadoop 2.7使用的log4j 1.2，下面主要写这一版本。
本文主要介绍log4j：
 根据日志级别记录日志 (logger上设置） 运行时决定具体的记录位置（appender上设置）和日志格式（layout上设置）  一些概念 日志级别（priority，代码里为level） 日志级别从低到高为trace, debug, info, warn, error, fatal。默认级别为info，低于设置级别的日志不会被打印。
常用组件 一般情况下常设置的组件有logger，appender， layout。
用类的方式表达三个组件的关系为
Logger{ name; level; // 控制日志级别 appenderList; // 可对应多个appender } Appender{ name; // 控制文件位置 如fileAppender layout; // 控制格式 filter; // 过滤部分日志 } logger logger以一种树状关系管理日志的类型，log4j.rootCategory为根节点，如果没有标记 log4j.additivity.MyLogger = false ，则子logger会默认继承上一级的设置。
通过树的组织形式，对不同的包中的不同的类，可以分别设置不同的日志方式。
通过点表示层级，如com.foo为com.foo.Bar的上级
关于category，早期的log4j使用category较多，但在log4j 1.2之后，建议使用logger代替category。
appender 主要用于
 控制日志的输出位置，当前支持the console, files, GUI components, remote socket servers, NT Event Loggers, and remote UNIX Syslog daemons.</description>
    </item>
    
  </channel>
</rss>